name: Build, Sign & Release EXE (Nuitka)

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-release:
    runs-on: windows-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      # 1. ÄNDERUNG: Nuitka statt PyInstaller installieren
      - name: Install dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          if (Test-Path "requirements.txt") { pip install -r requirements.txt }
          pip install nuitka zstandard ordered-set

      # 2. ÄNDERUNG: Version berechnen und als ENV-Variable speichern
      # Nuitka braucht kein Textfile, sondern die Version als String (1.5.0.0)
      - name: Generate Version String
        shell: python
        run: |
          import os
          
          # Tag holen (z.B. "v1.5.0") und "v" entfernen -> "1.5.0"
          tag = os.environ.get("GITHUB_REF_NAME", "0.0.0").lstrip("v")
          
          # Version für Windows-Format splitten (1, 5, 0, 0)
          parts = [p for p in tag.split(".") if p.isdigit()]
          while len(parts) < 4:
              parts.append("0")
          
          version_str = ".".join(parts) # Ergibt z.B. "1.5.0.0"
          
          # In Github Environment schreiben für spätere Steps
          with open(os.environ['GITHUB_ENV'], 'a') as f:
              f.write(f"APP_VERSION={version_str}\n")
              
          print(f"APP_VERSION set to {version_str}")

      # 3. ÄNDERUNG: Build mit Nuitka
      - name: Build EXE (Nuitka)
        shell: pwsh
        run: |
          # Hinweis: Nuitka lädt den C-Compiler (MinGW64) automatisch, falls kein MSVC da ist.
          # Auf 'windows-latest' ist MSVC aber vorinstalliert.
          
          python -m nuitka `
            --onefile `
            --standalone `
            --windows-console-mode=disable `
            --enable-plugin=tk-inter `
            --windows-icon-from-ico=".\timetable_icon.ico" `
            --company-name="Nico Dahlhaus" `
            --product-name="TimeTrac" `
            --file-description="TimeTrac – Zeiterfassung" `
            --copyright="© 2025 – Developed by Nico Dahlhaus" `
            --product-version="${{ env.APP_VERSION }}" `
            --file-version="${{ env.APP_VERSION }}" `
            --output-dir=".\dist" `
            --output-filename="timetrac.exe" `
            ".\main.py"
        # WICHTIG: Falls du NICHT tkinter nutzt, entferne --enable-plugin=tk-inter
        # Falls du PyQt6 nutzt, nimm: --enable-plugin=pyqt6
        # Falls du keine GUI hast (CLI Tool), entferne --windows-console-mode=disable

      # Ab hier bleibt der Prozess für das Signieren fast gleich, 
      # da Nuitka die Datei auch in .\dist\timetrac.exe ablegt.

      - name: Decode PFX Certificate
        shell: pwsh
        run: |
          $pfxPath = Join-Path -Path $env:RUNNER_TEMP -ChildPath "codesign.pfx"
          $encodedBytes = [Convert]::FromBase64String("${{ secrets.CODESIGN_PFX_BASE64 }}")
          [IO.File]::WriteAllBytes($pfxPath, $encodedBytes)
          "PFX_PATH=$pfxPath" >> $env:GITHUB_ENV

      - name: Find signtool.exe
        shell: pwsh
        run: |
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
            Where-Object { $_.FullName -match "\\x64\\signtool\.exe$" } |
            Sort-Object FullName -Descending |
            Select-Object -First 1 -ExpandProperty FullName
          if (-not $signtool) { throw "signtool.exe nicht gefunden" }
          "SIGNTOOL=$signtool" >> $env:GITHUB_ENV

      - name: Sign EXE
        shell: pwsh
        env:
          PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
        run: |
          & "$env:SIGNTOOL" sign /v `
            /f "$env:PFX_PATH" /p "$env:PFX_PASSWORD" `
            /fd SHA256 /tr "http://timestamp.sectigo.com" /td SHA256 `
            ".\dist\timetrac.exe"

      - name: Package ZIP
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path ".\release" | Out-Null
          if (Test-Path ".\dist\timetrac.exe") { Copy-Item ".\dist\timetrac.exe" ".\release\timetrac.exe" -Force }
          if (Test-Path ".\LICENSE") { Copy-Item ".\LICENSE" ".\release\LICENSE" -Force }
          
          $compressFiles = @(".\release\timetrac.exe")
          if (Test-Path ".\release\LICENSE") { $compressFiles += ".\release\LICENSE" }
          
          Compress-Archive -Path $compressFiles -DestinationPath ".\timetrac.zip" -Force

      - name: Create checksum
        shell: pwsh
        run: |
          Get-FileHash ".\timetrac.zip" -Algorithm SHA256 |
            ForEach-Object { "$($_.Hash)  timetrac.zip" } |
            Out-File "timetrac.zip.sha256" -Encoding ASCII

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: |
            timetrac.zip
            timetrac.zip.sha256
          generate_release_notes: true
