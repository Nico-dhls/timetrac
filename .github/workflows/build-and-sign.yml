name: Build & Sign MSI (cx_Freeze)

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      debug_version:
        description: 'Version für Debugging (z.B. 1.0.0)'
        required: true
        default: '0.0.0'

permissions:
  contents: write

jobs:
  build-sign-msi:
    runs-on: windows-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          if (Test-Path "requirements.txt") { pip install -r requirements.txt }
          pip install cx_Freeze

     # SCHRITT A (KORRIGIERT): Robuste Version Logik
      - name: Inject Version into setup.py
        shell: pwsh
        run: |
          # 1. Fall: Manueller Start (Workflow Dispatch)
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $rawVersion = "${{ inputs.debug_version }}"
            Write-Host "Trigger: Manuell. Eingabe: $rawVersion"
          
          # 2. Fall: Start durch Git Tag (z.B. v1.0.0)
          } elseif ($env:GITHUB_REF_TYPE -eq "tag") {
            $rawVersion = $env:GITHUB_REF_NAME.TrimStart("v")
            Write-Host "Trigger: Tag. Version: $rawVersion"
          
          # 3. Fall: Start durch normalen Push auf 'main' (Fallback)
          } else {
            Write-Warning "Trigger: Branch Push ('$env:GITHUB_REF_NAME'). Dies ist keine gültige Version."
            $rawVersion = "0.0.0"
            Write-Host "Benutze Fallback-Version: $rawVersion"
          }

          # Sicherheits-Check: Prüfen, ob die Version mit einer Zahl beginnt
          # Wenn immer noch Quatsch drin steht (z.B. "main"), erzwinge 0.0.0
          if ($rawVersion -notmatch "^\d") {
             Write-Warning "Version '$rawVersion' ist ungültig für Python. Setze auf 0.0.0 zurück."
             $rawVersion = "0.0.0"
          }

          # In setup.py schreiben
          Write-Host "Schreibe Version $rawVersion in setup.py..."
          (Get-Content setup.py) -replace 'VERSION_PLACEHOLDER', $rawVersion | Set-Content setup.py

      # SCHRITT B: MSI bauen
      # cx_Freeze erstellt nun die MSI mit der korrekten Version in den Metadaten
      - name: Build MSI
        shell: pwsh
        run: |
          python setup.py bdist_msi

      # SCHRITT C: Zertifikat vorbereiten
      - name: Decode PFX Certificate
        shell: pwsh
        run: |
          $pfxPath = Join-Path -Path $env:RUNNER_TEMP -ChildPath "codesign.pfx"
          $encodedBytes = [Convert]::FromBase64String("${{ secrets.CODESIGN_PFX_BASE64 }}")
          [IO.File]::WriteAllBytes($pfxPath, $encodedBytes)
          "PFX_PATH=$pfxPath" >> $env:GITHUB_ENV

      # SCHRITT D: Signtool finden
      - name: Find signtool.exe
        shell: pwsh
        run: |
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
            Where-Object { $_.FullName -match "\\x64\\signtool\.exe$" } |
            Sort-Object FullName -Descending |
            Select-Object -First 1 -ExpandProperty FullName
          "SIGNTOOL=$signtool" >> $env:GITHUB_ENV

      # SCHRITT E: Das MSI signieren
      # Wir suchen die MSI im dist-Ordner (Name ändert sich je nach Version) und signieren sie.
      - name: Sign MSI
        shell: pwsh
        env:
          PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
        run: |
          $msiFile = Get-ChildItem ".\dist\*.msi" | Select-Object -First 1
          Write-Host "Signiere Datei: $($msiFile.FullName)"
          
          & "$env:SIGNTOOL" sign /v `
            /f "$env:PFX_PATH" /p "$env:PFX_PASSWORD" `
            /fd SHA256 /tr "http://timestamp.sectigo.com" /td SHA256 `
            $msiFile.FullName

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: |
            dist/*.msi
          generate_release_notes: true
